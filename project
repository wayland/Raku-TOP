#!/usr/bin/raku

class	MethodLoc {
	has	Str	$.class;
	has	Str	$.methodname;
	has	Str	$.filename;
	has	Str	$.classtype;
	has		$.drivertype;
	has	Int	$.lineno;
}

multi	MAIN('build-docs', @filenames?) {
	# Set up
	my %doc-types = %(
		Markdown => 'md',
		HTML => 'html',
		Text => 'txt',
	);

	# Generate lists of source files
	my (@class-source-files) = qx{find lib \( -name '*.raku' -o -name '*.rakumod' \)}.lines;

	# Set up for processing READMEs
	my $readme-text = 'README.rakudoc'.IO.slurp;

	# Generate documentation
	for %doc-types.kv -> $format-name, $format-extension {
		# Generate Class References
		my (@class-pod);
		for @class-source-files -> $sourcefile {
			my ($basename, $target-file) = build-docs($format-name, $format-extension, 'Class', $sourcefile);

			push @class-pod, "=item L<class {$basename}|{$target-file}>"
		}

		# Generate Introductory Docs

		# Generate READMEs
		my %includes = %(
			class-refs => join("\n", @class-pod),
			intro-docs => 'ids',
		);

		my $this-readme-text = $readme-text;
		$this-readme-text ~~ s:g/\#include\s+(<[\w\-]>+)/{%includes{$0}}/;
		build-docs($format-name, $format-extension, 'README', 'README.rakudoc', source-text => $this-readme-text);
	}

}

multi	MAIN($action) {
	my $docker_compose_command = "docker-compose -f testing/docker/docker-compose.yml --project-directory .";

	given ($action) {
		when 'test' {
			do_cmd("$docker_compose_command up -d");
			do_cmd("docker exec raku_raku_1 /bin/bash -lc ./table-tests.rakutest 2>&1");
		}
		when 'build' {
			do_cmd("$docker_compose_command build raku");
		}
		when 'stop' {
			do_cmd("$docker_compose_command down");
		}
		when 'find-common' {
			# Locate methods in files and classes/roles
			my (@files-to-check) = qx{find lib/raku/Database/Driver -name '*.rakumod'}.lines;
			push @files-to-check, 'lib/raku/Database/Driver.rakumod';

			my @methodlocs;
			for @files-to-check -> $file {
				say "File: $file";
				my ($currentclass, $classtype, $drivertype);
				my $lineno = 0;
				for $file.IO.lines -> $line {
					$lineno++;
					$line ~~ /^\s*(role|class)\s+ $<classname> = (<[\w:]>+)/ and do {
						my $thisclass = ~$/<classname>;
						$line ~~ /\{$/ or next;
						$currentclass = $thisclass;
						my $d;
						($classtype, $d, $drivertype) = $thisclass.split(/\:\:/);
					}
					$line ~~ /
						[multi\s+|sub|<?>]method\s+
						$<method> = [<[\w-]>+].*
					/ and do {
						my $method = ~$<method>;
						defined($drivertype) and $line ~~ /\}$/ and next;
						push @methodlocs, MethodLoc.new(
							class => $currentclass,
							methodname => $method,
							lineno => $lineno,
							filename => $file,
							classtype => $classtype,
							drivertype => $drivertype,
						);
					};
				}
			}

			# Loop over methods and categorise
			my %groups;
			for @methodlocs -> $ml {
				push %groups{$ml.classtype ~ $ml.methodname}, $ml;
			}
			GROUP: for %groups.kv -> $key, @group {
				@group.elems > 1 and do {
					for @group -> $methodloc {
						defined($methodloc.drivertype) or next GROUP;
					}
#dd @group;
					for @group -> $methodloc {
						FIRST {
							printf "%s.%s:\n", $methodloc.classtype, $methodloc.methodname;
						}
						printf "\t%s: %s\n", $methodloc.filename, $methodloc.lineno;
					}
				};
			}
		}
		default {
			die "Unknown action '$action'";
		}
	}
}

sub	do_cmd($cmd, :$level = 1, :$use = 'shell') {
	print "+" x $level;
	say " $cmd";
	given $use {
		when 'shell' {
			shell $cmd;
		}
		when 'qqx' {
			print qqx{$cmd};
		}
	}

	return $!;
}

sub	build-docs($format-name, $format-extension, $type, $sourcefile, :$source-text = Nil) {
	my $basename = $sourcefile.IO.basename;
	$basename ~~ s/\.raku(mod|doc)$// or die "File with unrecognised extension: $basename";

	my $target-file = $type eq 'README' 
		?? "README.$format-extension"
		!! "docs/$format-name/$type/$basename.$format-extension";
	my $use-source-text;
	if ($source-text ~~ Nil) {
		$use-source-text = $sourcefile.IO.slurp;
		do_cmd("cat $sourcefile | RAKULIB=lib/raku raku --doc=$format-name - > $target-file", use => 'qqx');
		say "after";
	} else {
		$use-source-text = $source-text;
		my $p = shell "RAKULIB=lib/raku raku --doc=$format-name - > $target-file", :in;
		$p.in.say: $source-text;
		$p.in.close;
		say "Generated $target-file from source text";
	}

	##### GENERATE POD TABLE OF CONTENTS
	# ATTEMPT 2
	# This is the approach, but it needs a newer Raku
	# Drawn from https://github.com/Raku/doc/blob/main/xt/rakuast-validate.rakutest (start reading at the bottom of the file
#	for $use-source-text.AST.rakudoc -> $pod {
#		dd $pod
#	}

	# ATTEMPT 1
	# Not sure if this might be useful as a component in attempt 2, above; 
#	use	Pod::Contents;
#	say "Got: " ~ join_pod_contents_of $use-source-text, 'TITLE';

	return [$basename, $target-file];
}

