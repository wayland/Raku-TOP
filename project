#!/usr/bin/raku

use	JSON::Fast;

class	MethodLoc {
	has	Str	$.class;
	has	Str	$.methodname;
	has	Str	$.filename;
	has	Str	$.classtype;
	has		$.drivertype;
	has	Int	$.lineno;
}

# >>= TOP:ver<0.0.1>:auth<zef:wayland>
grammar	FezListItem {
	rule	TOP ($module)	{ '>>=' <.ws> $module <parameter>+ }
	rule	parameter	{ ':' <param-name> '<' <param-value> '>' }
	rule	param-name	{ \w+ }
	rule	param-value	{ <[\w:.]>+ }
}
class	FezListItemActions {
	method	TOP($match) {
		$match.make: $match<parameter>Â».made;
	}
	method	parameter($/) {
#		printf "Got %s -- %s\n", $/<param-name>, $/<param-value>;
		make $/<param-name>.made => $/<param-value>.made;
	}
	method	param-name($/)	{ make ~$/; }
	method	param-value($/)	{ make ~$/; }
}

multi	MAIN('release') {
	# Fetch version from META6.json
	my %metadata = from-json("META6.json".IO.slurp);
#	say %metadata;

# TODO: The build stuff was causing weird errors; revisit when I upgrade the raku version on my local
	# Set up promises
#	my $build-promise = start {
#		my $result = MAIN('build') and MAIN('stop') and MAIN('test');
#		$result and return $result;
#		return Nil;
#	}

	# Get existing fez versions so that we can ensure we're not releasing an existing version
	my $fez-list-promise = start {
		my @lines = qqx{fez list}.lines;
		my %versions;
		for @lines -> $line {
			my %params = FezListItem.parse(
				$line,
				:args(@(%metadata<name>)),
				actions => FezListItemActions.new(),
			).made;
			%versions{%params<ver>} = 1;
		}
		%versions{%metadata<version>};
	}
	# Run fez review so we can quit if it finds any problems
	my $fez-review-promise = start {
		my @lines = qqx{fez review}.lines;
		$!, @lines;
	}
	# Check the git tags to see if we've already tagged this version there
	my $git-tag-promise = start {
		my %tags = qqx{git tag -l v*}.lines.map: -> $_ is copy { s/^v//; $_ => 1 };
		%tags{%metadata<version>};
	}

	# Collate promised answers into @problems
	my @problems;
	my $gt-version = await $git-tag-promise;
	if $gt-version {
		@problems.push: "Can't create release '{%metadata<version>}': A git tag for this version already exists\n";
	}
	my ($fez-review-rv, @fez-review-lines) = await $fez-review-promise;
	if $fez-review-rv {
		@problems.push: "Can't create release '{%metadata<version>}': Fez review failed\n";
	}
	my $fez-version = await $fez-list-promise;
	if $fez-version {
		@problems.push: "Can't create release '{%metadata<version>}': A fez version with this ID already exists\n";
	}
#	my @build-errors = await $build-promise;
#	if @build-errors {
#		@problems.push: @build-errors;
#	}
	# If there were problems, die
	@problems.elems > 0 and do {
		@problems ==> map { "$_\n" } ==> join '' ==> die;
	};
	die "Needs fixing";
# Need to put in some code to check git status -- if there's anything that hasn't been checked in, it should cause an error

	# Finally ready to go
	do_cmd(sprintf(qq{git tag 'v%s'}, %metadata<version>), die => True);
	do_cmd(qq{git push --tags}, die => True);
	do_cmd(qq{fez upload}, die => True);
}

multi	MAIN('build-docs', @filenames?) {
	# Set up
	my %doc-types = %(
		Markdown => 'md',
		HTML => 'html',
		Text => 'txt',
	);

	# Generate lists of source files
	my (@class-source-files) = qx{find lib \( -name '*.raku' -o -name '*.rakumod' \)}.lines;

	# Set up for processing READMEs
	my $readme-text = 'README.rakudoc'.IO.slurp;

	# Generate documentation
	for %doc-types.kv -> $format-name, $format-extension {
		# Generate Class References
		my (@class-pod);
		for @class-source-files -> $sourcefile {
			my ($basename, $target-file) = build-docs($format-name, $format-extension, 'Class', $sourcefile);

			push @class-pod, "=item L<class {$basename}|{$target-file}>"
		}

		# Generate Introductory Docs

		# Generate READMEs
		my %includes = %(
			class-refs => join("\n", @class-pod),
			intro-docs => 'L<Raku Introductory Docs|https://wayland.github.io/table-oriented-programming/Raku-TOP/Introduction.xml>',
		);

		my $this-readme-text = $readme-text;
		$this-readme-text ~~ s:g/\#include\s+(<[\w\-]>+)/{%includes{$0}}/;
		build-docs($format-name, $format-extension, 'README', 'README.rakudoc', source-text => $this-readme-text);
	}

}

multi	MAIN($action) {
	my $docker_compose_command = "docker-compose -f testing/docker/docker-compose.yml --project-directory .";

	given ($action) {
		when 'test' {
			do_cmd("$docker_compose_command up -d");
			do_cmd("docker exec raku_raku_1 /bin/bash -lc ./table-tests.rakutest 2>&1");
		}
		when 'build' {
			do_cmd("$docker_compose_command build raku");
		}
		when 'stop' {
			do_cmd("$docker_compose_command down");
		}
		when 'find-common' {
			# Locate methods in files and classes/roles
			my (@files-to-check) = qx{find lib/raku/Database/Driver -name '*.rakumod'}.lines;
			push @files-to-check, 'lib/raku/Database/Driver.rakumod';

			my @methodlocs;
			for @files-to-check -> $file {
				say "File: $file";
				my ($currentclass, $classtype, $drivertype);
				my $lineno = 0;
				for $file.IO.lines -> $line {
					$lineno++;
					$line ~~ /^\s*(role|class)\s+ $<classname> = (<[\w:]>+)/ and do {
						my $thisclass = ~$/<classname>;
						$line ~~ /\{$/ or next;
						$currentclass = $thisclass;
						my $d;
						($classtype, $d, $drivertype) = $thisclass.split(/\:\:/);
					}
					$line ~~ /
						[multi\s+|sub|<?>]method\s+
						$<method> = [<[\w-]>+].*
					/ and do {
						my $method = ~$<method>;
						defined($drivertype) and $line ~~ /\}$/ and next;
						push @methodlocs, MethodLoc.new(
							class => $currentclass,
							methodname => $method,
							lineno => $lineno,
							filename => $file,
							classtype => $classtype,
							drivertype => $drivertype,
						);
					};
				}
			}

			# Loop over methods and categorise
			my %groups;
			for @methodlocs -> $ml {
				push %groups{$ml.classtype ~ $ml.methodname}, $ml;
			}
			GROUP: for %groups.kv -> $key, @group {
				@group.elems > 1 and do {
					for @group -> $methodloc {
						defined($methodloc.drivertype) or next GROUP;
					}
#dd @group;
					for @group -> $methodloc {
						FIRST {
							printf "%s.%s:\n", $methodloc.classtype, $methodloc.methodname;
						}
						printf "\t%s: %s\n", $methodloc.filename, $methodloc.lineno;
					}
				};
			}
		}
		default {
			die "Unknown action '$action'";
		}
	}
}

sub	do_cmd($cmd, :$level = 1, :$use = 'shell', :$die = False) {
	print "+" x $level;
	say " $cmd";
	given $use {
		when 'shell' {
			shell $cmd;
		}
		when 'qqx' {
			print qqx{$cmd};
		}
	}
	$die and $! and die "Command failed!";

	return $!;
}

sub	build-docs($format-name, $format-extension, $type, $sourcefile, :$source-text = Nil) {
	my $basename = $sourcefile.IO.basename;
	$basename ~~ s/\.raku(mod|doc)$// or die "File with unrecognised extension: $basename";

	my $target-file = $type eq 'README' 
		?? "README.$format-extension"
		!! "docs/$format-name/$type/$basename.$format-extension";
	my $use-source-text;
	if ($source-text ~~ Nil) {
		$use-source-text = $sourcefile.IO.slurp;
		do_cmd("cat $sourcefile | RAKULIB=lib/raku raku --doc=$format-name - > $target-file", use => 'qqx');
	} else {
		$use-source-text = $source-text;
		my $p = shell "RAKULIB=lib/raku raku --doc=$format-name - > $target-file", :in;
		$p.in.say: $source-text;
		$p.in.close;
		say "Generated $target-file from source text";
	}

	##### GENERATE POD TABLE OF CONTENTS
	# ATTEMPT 2
	# This is the approach, but it needs a newer Raku
	# Drawn from https://github.com/Raku/doc/blob/main/xt/rakuast-validate.rakutest (start reading at the bottom of the file
#	for $use-source-text.AST.rakudoc -> $pod {
#		dd $pod
#	}

	# ATTEMPT 1
	# Not sure if this might be useful as a component in attempt 2, above; 
#	use	Pod::Contents;
#	say "Got: " ~ join_pod_contents_of $use-source-text, 'TITLE';

	return [$basename, $target-file];
}

